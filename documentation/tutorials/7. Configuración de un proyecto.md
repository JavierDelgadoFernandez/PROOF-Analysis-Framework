# PAF::Configuración de un proyecto
En anteriores tutoriales, ya se ha configurado un PAFProject tanto para la primera ejecución como para mostrar el paso de parámetros, pero no se mostrado aún todo su potencial. A continuación se muestran las funcionalidades que tiene, aunque casi todos los métodos estan sobrecargados, por lo que se recomienda mirar la documentación de clases.

## Entorno de ejecución
Hasta ahora hemos utilizado el entorno de ejecución que PAF pone por defecto. Este entorno no es otro que PROOFLite, el cual se ejecuta localmente y no necesita de una configuración muy compleja. Pero PAF ofrece actualmente más entornos, como un entorno secuencial (PAFSequentialEnvironment), el cual lanza con un sólo hilo de ejecución el análisis, permitiéndonos depurar de forma cómoda. PROOF Lite (PAFPROOFLiteEnvironment), el cual espera como parámetro en su constructor el número de esclavos y dos entornos más para trabajar con PROOF Cloud (PAFPROODCloudEnvironment) y PAF Cluster (PAFPROOFClusterEnvironment). 

El entorno de ejecución es un miembro del proyecto, por lo que para establecerlo, basta con hacer el set correspondiente:
```cpp
PAFProject* myProject = new PAFProject();
PAFSequentialEnvironment* executionEnvironment = new PAFSequentialEnvironment();
myProject->SetExecutionEnvironment(executionEnvironment);
```
O, si queremos dejarlo más limpio, se ha creado un constructor de PAFProject el cual espera como parámetro el entorno de ejecución, quedando este ejemplo en:
```cpp
PAFProject* myProject = new PAFProject( new PAFSequentialEnvironment() );
```
## Librerias, paquetes y selectores
PAF contempla el uso de varios tipos de código ejecutable. En el caso de que queramos añadir una librería al proyecto porque se necesita para la ejecución, podemos aprovechar el método AddLibrary:
```cpp
myProject->AddLibrary("/home/javier/Documents/Foo.so");
```
Misma situación para un paquete. La diferencia de un paquete respecto a una librería, es que un paquete es código fuente no compilado aún, es decir, código auxiliar pero no analizadores. Se deberá indicar el nombre del paquete simplemente, ya que PAF lo buscará en los repositorios configurados (se explicó como configurar repositorios en el tutorial 2):
```cpp
myProject->AddPackage("FFT");
```
Y por último selectores. Un selector es un paquete especial que será ejecutado por PAF, por lo que debe tener al menos una clase con el mismo nombre que el nombre del paquete y que herede de PAFChainItemSelector. Al igual que en un paquete, sólo necesitamos indicar su nombre porque PAF buscará en los repositorios:
```cpp
myProject->AddSelectorPackage("MyAnalysis");
```
También se ofrece la posiblidad de establecer a mano un vector para cada uno de estos 3 elementos:
```cpp
myProject->SetLibraries(myLibraries);
myProject->SetPackages(mySelectorPackagesVector);
myProject->SetSelectorPackages(mySelectorPackagesVector);
```
## Archivos de entrada
Los archivos de entrada son los archivos ROOT que procesará el proyecto. Aunque en los ejemplos se ha mostrado siempre pasándo un string:
```cpp
myProject->AddDataFile("/home/javier/Documents/ROOT_FILE.root");
```
Está sobrecargado, pudiéndo esperar también un puntero a TFileInfo, más útil cuando se usan sistemas de archivos más complejos.

Igual que en el caso de los paquetes, se puede utilizar un SetDataFiles para establecer un TFileCollection* ya configurado.

## Archivo de salida
En caso de querer dejar los resultados de la ejecución en un archivo ROOT, basta con indicarle el nombre del archivo:
```cpp
myProject->SetOutputFile("/home/javier/Documents/Result.root");
```
En este caso, todos los histogramas y toda la información que generen los selectores, será volcada al archivo indicado.

## Parámetros de entrada
Como ya se vió en el anterior tutorial como utilizar los parámetros de entrada, simplemente es:
```cpp
myProject->SetInputParam("Weight", 1.234567);
```
Pero podemos establecer, aunque nada recomendado, un puntero a PAFVariableContainer si lo deseamos.
```cpp
PAFVariableContainer* variables = new PAFVariableContainer();
(...)
myProject->SetInputParameters(variables);
```

## Histogramas dinámicos
En caso de que queramos ver en tiempo real el análisis, sólo deberemos especificar a PAF qué histogramas queremos ir viendo:
```cpp
myProject->AddDynamicHistogram("myHistogram");
```
También se ofrece la opción de establecer un vector con todos:
```cpp
std::vector<TString>* dynamicHistograms = new std::vector<TString>();
(...)
myProject->AddDunamicHistograms(dynamicHistograms);
```

## Lugar de compilación
Mediante el método SetCompileOnSlaves le indicamos a PAF si queremos compilar en cada esclavo, o si queremos compilar en el cliente y pasar el ejecutable a los esclavos. Resulta más cómoda esta opción siempre y cuando tengamos un clúster con la misma arquitectura. Por dejecto, PAF viene ajustado de esta manera.
```cpp
myProject->SetCompileOnSlaves(true);
```